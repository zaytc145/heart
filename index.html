<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Алия самая красивая</title>
  <style>
    :root {
      --pink: #ffc0cb;
      --red: #e0112b;
      --text: #a0001a;
      --btn-bg: #fff0f4;
      --btn-border: #e88aa1;
      --btn-text: #9c1030;
      --btn-hover: #ffe1ea;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--pink);
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    }
    .content {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2.25rem;
      padding: 2rem;
    }
    h1 {
      margin: 0;
      color: var(--text);
      font-weight: 800;
      letter-spacing: 0.02em;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
      font-size: clamp(2rem, 4vw + 1rem, 4rem);
    }
    .heart {
      width: min(60vmin, 820px);
      max-width: 95vw;
      height: auto;
      display: block;
      filter: drop-shadow(0 12px 24px rgba(160, 0, 26, 0.25));
    }
    .btn {
      appearance: none;
      border: 2px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-text);
      font-weight: 700;
      padding: 0.85rem 1.25rem;
      border-radius: 999px;
      cursor: pointer;
      font-size: clamp(1rem, 1vw + 0.75rem, 1.125rem);
      box-shadow: 0 6px 14px rgba(156, 16, 48, 0.15);
      transition: transform .08s ease, background-color .2s ease, box-shadow .2s ease;
    }
    .btn:hover { background: var(--btn-hover); transform: translateY(-1px); }
    .btn:active { transform: translateY(0); box-shadow: 0 3px 8px rgba(156, 16, 48, 0.18); }
    .btn:focus-visible { outline: 3px solid #ffd4e0; outline-offset: 2px; }

    /* Fullscreen canvas for hearts (сердечки) */
    .fireworks {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none; /* clicks pass through */
      display: none; /* shown only during animation */
      z-index: 10;
    }

    @media (prefers-reduced-motion: reduce) {
      .fireworks { display: none !important; }
    }
  </style>
</head>
<body>
  <main class="content">
    <h1>Алия самая красивая</h1>

    <!-- Огромное красное сердце -->
    <svg class="heart" viewBox="0 0 100 90" role="img" aria-label="Красное сердце">
      <path fill="var(--red)" d="M50 15 C35 0, 0 0, 0 25 C0 35, 10 55, 50 80 C90 55, 100 35, 100 25 C100 0, 65 0, 50 15 Z"/>
    </svg>

  </main>

  <!-- Полноэкранный холст для сердечек -->
  <canvas id="fireCanvas" class="fireworks" aria-hidden="true"></canvas>

  <script>
    (function() {
      // Автозапуск: кнопки больше нет
      // const btn = document.getElementById('fireButton');
      const canvas = document.getElementById('fireCanvas');
      const ctx = canvas.getContext('2d');
      let particles = [];
      let raf = null;
      let running = false;
      let heartInterval = null;

      function resize() {
        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
        canvas.width = Math.floor(canvas.clientWidth * dpr);
        canvas.height = Math.floor(canvas.clientHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      // Setup canvas size based on viewport
      function ensureShown() {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
        canvas.style.display = 'block';
        // Ensure it spans viewport in case CSS changed by mobile UI
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        resize();
      }

      window.addEventListener('resize', () => { if (running) resize(); });

      function rand(min, max) { return Math.random() * (max - min) + min; }
      function hsla(h, s, l, a) { return `hsla(${h}, ${s}%, ${l}%, ${a})`; }

      // Область сердца (примерная) — чтобы не спавнить взрывы поверх большого сердца в центре
      function getHeartBounds(w, h) {
        const cx = w / 2;
        const cy = h / 2;
        const s = Math.min(w, h);
        // Полуоси прямоугольника запрета (подобрано эмпирически под 60vmin SVG)
        const halfW = s * 0.22; // ширина запретной зоны ≈ 44% от min(w,h)
        const halfH = s * 0.18; // высота запретной зоны ≈ 36% от min(w,h)
        return { left: cx - halfW, right: cx + halfW, top: cy - halfH, bottom: cy + halfH };
      }

      function pointInHeartBounds(x, y, bounds) {
        return x > bounds.left && x < bounds.right && y > bounds.top && y < bounds.bottom;
      }

      function randomPointAvoidHeart(w, h) {
        const bounds = getHeartBounds(w, h);
        // Пытаемся найти точку вне запретной зоны, предпочтительно в видимых пределах
        for (let i = 0; i < 20; i++) {
          const x = rand(w * 0.1, w * 0.9);
          const y = rand(h * 0.15, h * 0.85);
          if (!pointInHeartBounds(x, y, bounds)) return { x, y };
        }
        // Фоллбек: выбираем одну из областей по бокам/сверху от сердца
        const pick = Math.random();
        if (pick < 0.33) return { x: rand(0, Math.max(0, bounds.left - 10)), y: rand(0, h) };
        if (pick < 0.66) return { x: rand(Math.min(w, bounds.right + 10), w), y: rand(0, h) };
        return { x: rand(0, w), y: rand(0, Math.max(0, bounds.top - 10)) };
      }

      // Рисуем сердечко в точке (x, y) размером size и поворотом rotation
      function drawHeart(ctx, x, y, size, rotation) {
        const s = size;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.beginPath();
        // Нормализованная форма сердечка с кривыми Безье
        ctx.moveTo(0, -0.25 * s);
        ctx.bezierCurveTo(0.35 * s, -0.6 * s, 0.95 * s, -0.1 * s, 0, 0.6 * s);
        ctx.bezierCurveTo(-0.95 * s, -0.1 * s, -0.35 * s, -0.6 * s, 0, -0.25 * s);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function burst(x, y) {
        const colors = [350, 0, 10, 340, 360, 5].map(h => (h + Math.floor(rand(-8, 8)) + 360) % 360);
        const count = Math.floor(rand(40, 70));
        for (let i = 0; i < count; i++) {
          const angle = rand(0, Math.PI * 2);
          const speed = rand(1.2, 3.2);
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: rand(1.2, 2.0),
            age: 0,
            size: rand(8, 14), // сердечки крупнее, чем точки
            hue: colors[Math.floor(rand(0, colors.length))],
            sparkle: Math.random() < 0.18,
            rot: rand(0, Math.PI * 2),
            spin: rand(-0.08, 0.08)
          });
        }
      }

      function animate(ts) {
        if (!running) return;
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        const gravity = 0.02;
        const friction = 0.992;
        let alive = 0;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.age += 1/60;
          p.vx *= friction;
          p.vy = p.vy * friction + gravity;
          p.x += p.vx;
          p.y += p.vy;
          p.rot += p.spin;
          const t = p.age / p.life;
          const alpha = Math.max(0, 1 - t);
          if (alpha <= 0) continue;
          alive++;
          const flicker = p.sparkle ? (Math.random() * 0.15) : 0;
          ctx.fillStyle = hsla(p.hue, 85, 54, alpha);
          drawHeart(ctx, p.x, p.y, p.size * (1 + flicker), p.rot);
        }
        // Remove dead particles occasionally to avoid cost of splice in loop
        particles = particles.filter(p => (p.age / p.life) < 1 && p.x>-80 && p.x<canvas.clientWidth+80 && p.y>-80 && p.y<canvas.clientHeight+120);

        if (particles.length === 0) {
          running = false;
          canvas.style.display = 'none';
          cancelAnimationFrame(raf);
          raf = null;
          return;
        }
        raf = requestAnimationFrame(animate);
      }

      function launchShow(centerBased = true) {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          // Respect reduced motion: no animation
          return;
        }
        ensureShown();
        running = true;
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const bursts = 4 + Math.floor(Math.random()*3); // 4-6 залпов
        for (let i = 0; i < bursts; i++) {
          const p = randomPointAvoidHeart(w, h);
          burst(p.x, p.y);
        }
        if (!raf) raf = requestAnimationFrame(animate);
      }

      // Авто-спавн: каждые 2 секунды по 3 случайных залпа в разных местах
      function spawnRandomBursts() {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
        ensureShown();
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        for (let i = 0; i < 5; i++) {
          const p = randomPointAvoidHeart(w, h);
          burst(p.x, p.y);
        }
        running = true;
        if (!raf && particles.length) raf = requestAnimationFrame(animate);
      }

      function startAutoHearts() {
        if (heartInterval || window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
        spawnRandomBursts();
        heartInterval = setInterval(spawnRandomBursts, 1000);
      }

      // Автозапуск: кнопка удалена

      // Optional: tap/click anywhere to add an extra burst (но не в области сердца)
      document.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        let x = (e.clientX - rect.left);
        let y = (e.clientY - rect.top);
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const bounds = getHeartBounds(w, h);
        if (pointInHeartBounds(x, y, bounds)) {
          const p = randomPointAvoidHeart(w, h);
          x = p.x; y = p.y;
        }
        particles.length = Math.min(particles.length, 1000);
        burst(x, y);
        if (!raf && particles.length) { running = true; ensureShown(); raf = requestAnimationFrame(animate); }
      });

      // Initialize canvas size once DOM painted and start auto hearts
      window.addEventListener('load', () => {
        // Make sure canvas CSS size matches viewport so clientWidth/Height are correct
        canvas.style.width = '100vw';
        canvas.style.height = '100vh';
        startAutoHearts();
      });

      // Optional: free interval on unload
      window.addEventListener('beforeunload', () => {
        if (heartInterval) clearInterval(heartInterval);
      });
    })();
  </script>
</body>
</html>